<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>棋盘覆盖问题</title>
		<style type="text/css">
			.chess{margin: 50px;}
			.chesstable{border: 2px solid;border-collapse: collapse;}
			.chesstr{height: 20px;border: 1px solid #ccc;}
			.chesstd{width: 20px;border: 1px solid #ccc;}
		</style>
		<script src="js/vue.js" type="text/javascript" charset="utf-8"></script>
	</head>
	<body>
		<div id="app">
			<h1 align="center">棋盘覆盖问题</h1>
			<p>
				问题：在一个2k×2k （k≥0）个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为特殊方格。&#10
				棋盘覆盖问题要求用图（b）所示的4种不同形状的L型骨牌覆盖给定棋盘上除特殊方格以外的所有方格，且&#10
				任何2个L型骨牌不得重叠覆盖。
			</p>
			<p>设置棋盘大小：
				<input type="text" v-model="side" placeholder="请输入棋盘边长(棋盘方格数-1能被3整除)" style="width:300px"/>
				<!-- <button type="button" v-on:click="creatBlind(side)">生成空白棋盘</button> -->
			</p>
			<p>输入特殊方格的位置：
				<p>
					x:<input v-model="x"  type="text" /><br>
					y:<input v-model="y" type="text" />
				</p>
			</p>
			<button type="button" v-on:click="getChessBoard(side,x,y)">L型骨牌覆盖棋盘</button>
			
			<div id="chess" class="chess">
				<table class="chesstable">
					<tr v-for="(chessrow,indexr) in chessrows" class="chesstr">
						<td v-for="(chesscol,indexc) in chesscols" class="chesstd" v-bind:style="{background:'rgb('+13*Matrix[indexr][indexc]%256+','+43*Matrix[indexr][indexc]%256+','+73*Matrix[indexr][indexc]%256+')'}"></td>
					</tr>
				</table>
			</div>
		</div>
		<script type="text/javascript">
			let app = new Vue({
				el:'#app',
				data:{
					side:'',
					x:'',
					y:'',
					chessrows:[],
					chesscols:[],
					Matrix:[],
					nCount:0,
				},
				methods:{
					//判断边长是否合规，合规返回true
					isLegalSide:function(s){
						if(s > 0 && s < 200){
							if ((s * s - 1) % 3 == 0 && s % 2 == 0){
								return true;
							}else{
								alert("方格数减一无法被3整除，棋盘无法被覆盖,请重新输入…")
								return false;
							}
						}else{
							if (s > 200){
								alert("边长过大，建议低于200，请重新输入…");
								return false;
							}
							alert("请输入符合的边长…");
							return false;
						}
					},
					
					//判断x，y是否合规，合规返回true
					isLegalXY:function(x,y){
						//必须用类型转换，不然无法比较
						var side = parseInt(this.side);
						if ((x <= side && x > 0) && (y <= side && y > 0)){
							return true;
						}
						alert("请输入合规的坐标...");
						return false;
					},
					
					//生成用L型骨牌覆盖的棋盘
					getChessBoard:function(s,s1,s2){
						if(this.isLegalSide(s) == false || this.isLegalXY(s1,s2) == false){
							this.side = '';
							this.x = '';
							this.y = '';
							return ;
						}else{
							this.chessrows.splice(0,this.chessrows.length);
							this.chesscols.splice(0,this.chesscols.length);
							this.Matrix.splice(0,this.Matrix.length);
							this.nCount = 0;
							for (var i = 0; i < this.side; i++) {
								this.chessrows.push('{}');
							}
							for (var j = 0; j < this.side; j++){
								this.chesscols.push('{}');
							}
							//初始化棋盘矩阵
							this.Matrix = new Array();
							for (var i = 0; i < this.side; i++) {
								this.Matrix[i] = new Array();
								for(var j = 0; j < this.side; j++){
									this.Matrix[i][j] = 0;
								}
							}
							this.chessBoard(0,0,this.x-1,this.y-1,this.side);
							// console.log(this.Matrix)
						}
					},
					
					//分治法处理棋盘矩阵
					chessBoard:function(tr,tc,dr,dc,size){
						var s,t;
						if (size == 1) return;
						s =size/2;
						t = ++this.nCount ;
						if (dr < tr + s && dc < tc +s)
						  this.chessBoard(tr,tc,dr,dc,s);
						else
						{
						  this.Matrix[tr+s-1][tc+s-1] = t;
						  this.chessBoard(tr,tc,tr+s-1,tc+s-1,s);
						}
						if (dr < tr + s && dc >= tc + s )
						  this.chessBoard(tr,tc+s,dr,dc,s);
						else
						{
						  this.Matrix[tr+s-1][tc+s] = t;
						  this.chessBoard(tr,tc+s,tr+s-1,tc+s,s);
						}
						if (dr >= tr + s && dc < tc + s)
						  this.chessBoard(tr+s,tc,dr,dc,s); 
						else
						{
						  this.Matrix[tr+s][tc+s-1] = t;
						  this.chessBoard(tr+s,tc,tr+s,tc+s-1,s);
						}
						if (dr >= tr + s && dc >= tc + s)
						  this.chessBoard(tr+s,tc+s,dr,dc,s);
						else
						{
						  this.Matrix[tr+s][tc+s] = t;
						  this.chessBoard(tr+s,tc+s,tr+s,tc+s,s);
						}
					}
				}
			})
		</script>
	</body>
</html>
